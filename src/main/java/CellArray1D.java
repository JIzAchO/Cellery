import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import cellery.topology.Topology1D;
import cellery.topology.Topology1D.Base;
import cellery.topology.Topology1D.Space;


/**
 * CellArray1D is a 1-d array of {@link Cell} objects which can kill or resurrect Cells and
 * retrieve neighborhoods about individual Cells.
 * @author Zach Tidwell
 */
public class CellArray1D {
	
	/**
	 * the number of Cells in this.
	 */
	public final int length;
	
	/**
	 * the underlying array of Cells
	 */
	private final Cell[] cells;
	
	/**
	 * The topology of this CellArray2D
	 */
	protected Topology1D topo;
	
	/**
	 * the name of the getNeighborhood method specified by topo
	 */
	private Method getNeighborhood;
	
	/**
	 * Instantiates a {@link CellArray1D} from an int array with the standard radial topology 
	 * of the fineness granularity.
	 * @param intArray an array of ints representing the initial states of this
	 */
	public CellArray1D(int[] intArray){
		this(initializeCells(intArray), new Topology1D(Base.RADIAL, 1, Space.STD) );
	}
	
	/**
	 * Instantiates a {@link CellArray1D} of length containing only dead {@linkplain Cell}s.
	 * @param length the number of Cells in the array 
	 */
	public CellArray1D(int length, Topology1D topo) {
		this(initializeCells(new int[length]), topo);
	}

	/**
	 * Instantiates a {@link CellArray1D} from an array of integers.
	 * @param intArray the generating array
	 */
	public CellArray1D(int[] intArray, Topology1D topo) {
		this(initializeCells(intArray), topo);

	}

	/**
	 * Instantiates a {@link CellArray1D} from a {@link Cell}[]
	 * @param cells an array of cells
	 */
	protected CellArray1D(Cell[] cells, Topology1D topo) {
		this.length = cells.length;
		this.cells = cells;
		this.topo = topo;
		
		String neighborhood = this.topo.getBasis().getMethodName();
		
		Class<?>[] args = {int.class, int.class};
		
		try {
			this.getNeighborhood = this.getClass().getMethod(neighborhood, args);
		} catch (NoSuchMethodException | SecurityException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Initializes a {@link Cell}[] from an integer array. A living Cell is placed in the index corresponding 
	 * to a value of 1 in the input integer array and dead cells are placed everywhere else. 
	 * @param intArray the input array.
	 * @return the array of Cells generated by input array.
	 */
	protected static Cell[] initializeCells(int[] intArray) {
		Cell[] newCells = new Cell[intArray.length];
		for (int i = 0; i < intArray.length; i++) {
			newCells[i] = new Cell(intArray[i]);
		}
		return newCells;
	}
	
	/**
	 * Retrieves the number of living {@link Cell}s in a region of radius r to the left of the 
	 * Cell at position i
	 * @param i the position of the Cell
	 * @param r the radius of the left-hand region 
	 */
	public int leftOf(int i, int r){
		int sum = 0;
		for ( int n = i - r; n < i ; n ++ ){
			if ( !(n<0) )
				sum += this.getCell(n).toBit();
		}
		return sum;
	}
	
	/**
	 * Retrieves the number of living {@link Cell}s in a region of radius r to the right of the 
	 * Cell at position i
	 * @param i the position of the Cell
	 * @param r the radius of the right-hand region 
	 */
	public int rightOf(int i, int r){
		int sum = 0;
		for ( int n = i + r; n > i ; n--){
			if ( !(n >= this.length) ){
				sum += this.getCell(n).toBit();
			}
		}
		return sum;
	}
	
	/**
	 * Retrieves the {@link CellArray1D} containing the {@link Cell}s about the i-th Cell in a
	 * symmetric neighborhood of radius r.
	 * @param i the index of the center of the neighborhood
	 * @param r the radius of the neighborhood
	 * @return CellArray containing the neighboring cells.
	 */
	public int radial(int i, int r) {
		return (this.rightOf(i, r) + this.leftOf(i, r));
	}
	
	/**
	 * Gets the neighborhood that is specified by this topology
	 * @param i the index of the neighborhood center
	 * @return the number of living Cells in this neighborhood
	 */
	public int getNeighborhood(int i){
		
		int r = this.topo.coarseness;
		
		try {
			return (int) getNeighborhood.invoke(this, i, r);
			
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			e.printStackTrace();
			return 0;
		}
	}
	
	/**
	 * Retrieve the {@link Topology1D} of this
	 * @return the {@link Topology1D}
	 */
	public Topology1D getTopology(){
		return this.topo;
	}
	
	/**
	 * Gives an array of binary Values corresponding to the {@link Cell}s in this.
	 * 1 indicates that the Cell is alive and 0 indicates that it is dead.
	 * @return the binary array represented the states of Cells in this
	 */
	public int[] toArray() {
		int[] bin = new int[this.length];
		for (int i = 0; i < this.length; i++) {
			bin[i] = this.cells[i].toBit();
		}
		return bin;
	}

	/**
	 * Computes the number of living Cells in this.
	 * @return the number of living cells in this.
	 */
	public int livingCells() {
		int sum = 0;
		for (Cell cell : this.cells) {
			sum += cell.toBit();
		}
		return sum;
	}

	/**
	 * Retrieves the {@link Cell} at position i.
	 * @param i index of the cell.
	 * @return the Cell at position i.
	 */
	public Cell getCell(int i) {
		return cells[i];
	}

	/**
	 * Kills the {@link Cell} at position i
	 * @param i the position of the Cell
	 */
	public void killCell(int i) {
		this.cells[i].kill();
	}

	/**
	 * Revives the {@link Cell} at position i.
	 * @param i the position of the Cell.
	 */
	public void reviveCell(int i) {
		this.cells[i].revive();
	}
	
	/**
	 * Translates this into a String containing binary integers representing the {@link Cell} states of this.
	 * @return a string representing this.
	 */
	@Override
	public String toString() {
		StringBuilder theString = new StringBuilder();
		theString.append("[");
		for (int i = 0; i < this.length; i++) {
			theString.append(this.getCell(i).toBit());
			if (i < this.length - 1)
				theString.append(", ");
		}
		theString.append("]");
		return theString.toString();
	}
}
