package cellery;

import java.util.ArrayList;


/**
 * CellArray1D is a 1-d array of {@link Cell} objects which can kill or resurrect Cells and
 * retrieve neighborhoods about individual Cells.
 * @author Zach Tidwell
 */
public class CellArray1D {

	public final int length;
	private final Cell[] cells;
	private final ArrayList<Cell> roster = new ArrayList<Cell>();

	/**
	 * Instantiates a {@link CellArray1D} of length containing only dead {@linkplain Cell}s.
	 * @param length the number of Cells in the array 
	 */
	public CellArray1D(int length) {
		this(initializeCells(new int[length]));
	}

	/**
	 * Instantiates a {@link CellArray1D} from an array of integers.
	 * @param intArray the generating array
	 */
	public CellArray1D(int[] intArray) {
		this(initializeCells(intArray));

	}

	/**
	 * Instantiates a {@link CellArray1D} from a {@link Cell}[]
	 * @param cells an array of cells
	 */
	protected CellArray1D(Cell[] cells) {
		this.length = cells.length;
		this.cells = cells;
	}

	/**
	 * Initializes a {@link Cell}[] from an integer array. A living Cell is placed in the index corresponding 
	 * to a value of 1 in the input integer array and dead cells are placed everywhere else. 
	 * @param intArray the input array.
	 * @return the array of Cells generated by input array.
	 */
	protected static Cell[] initializeCells(int[] intArray) {
		Cell[] newCells = new Cell[intArray.length];
		for (int i = 0; i < intArray.length; i++) {
			newCells[i] = new Cell(intArray[i]);
		}
		return newCells;
	}

	/**
	 * Retrieves the {@link CellArray1D} containing the {@link Cell}s about the i-th Cell in a
	 * symmetric neighborhood of radius r.
	 * @param i the index of the center of the neighborhood
	 * @param r the radius of the neighborhood
	 * @return CellArray containing the neighboring cells.
	 */
	public CellArray1D getNeighbors(int i, int r) {
		roster.clear();
		if (r > this.length / 2)
			r = this.length / 2;
		for (int x = i - r; x <= i + r; x++) {
			if (!(x < 0) && !(x >= this.length) && (x != i))
				roster.add(this.getCell(x));
		}
		return new CellArray1D(roster.toArray(new Cell[roster.size()]));
	}

	/**
	 * Gives an array of binary Values corresponding to the {@link Cell}s in this.
	 * 1 indicates that the Cell is alive and 0 indicates that it is dead.
	 * @return the binary array represented the states of Cells in this
	 */
	public int[] toBinaryArray() {
		int[] bin = new int[this.length];
		for (int i = 0; i < this.length; i++) {
			bin[i] = this.cells[i].toBit();
		}
		return bin;
	}

	/**
	 * Computes the number of living Cells in this.
	 * @return the number of living cells in this.
	 */
	public int livingCells() {
		int sum = 0;
		for (Cell cell : this.cells) {
			sum += cell.toBit();
		}
		return sum;
	}

	/**
	 * Retrieves the {@link Cell} at position i.
	 * @param i index of the cell.
	 * @return the Cell at position i.
	 */
	public Cell getCell(int i) {
		return cells[i];
	}

	/**
	 * Kills the {@link Cell} at position i
	 * @param i the position of the Cell
	 */
	public void killCell(int i) {
		this.cells[i].kill();
	}

	/**
	 * Revives the {@link Cell} at position i.
	 * @param i the position of the Cell.
	 */
	public void reviveCell(int i) {
		this.cells[i].revive();
	}
	
	/**
	 * Translates this into a String containing binary integers representing the {@link Cell} states of this.
	 * @return a string representing this.
	 */
	@Override
	public String toString() {
		StringBuilder theString = new StringBuilder();
		theString.append("[");
		for (int i = 0; i < this.length; i++) {
			theString.append(this.getCell(i).toBit());
			if (i < this.length - 1)
				theString.append(", ");
		}
		theString.append("]");
		return theString.toString();
	}
}
