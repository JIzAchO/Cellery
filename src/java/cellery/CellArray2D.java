package cellery;
import cellery.topology.Topology2D;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;


/**
 * A CellArray2D is a two dimensional grid of {@link Cell}s. This object provides information to a client 
 * {@link Automaton2D} about the states of Cells in a region with a geometry that is specified by an instance 
 * of a {@link cellery.topology.Topology2D}.
 * @author Zach Tidwell
 * @see {@link cellery.topology.Topology2D}, {@link Automaton2D}, {@link Cell}
 */
public class CellArray2D{
	
	/**
	 * The vertical dimension of this CellArray2D
	 */
	public final int length;
	
	/**
	 * The horizontal dimension of this CellArray2D
	 */
	public final int width;
	
	/**
	 * The underlying array
	 */
	private final Cell[][] cells;
	/**
	 * The topology of this CellArray2D
	 */
	protected Topology2D topo;
	
	/**
	 * the name of the getNeighborhood method specified by topo
	 */
	private Method getNeighborhood;
	
	/**
	 * Creates a {@link CellArray2D} from an array of ints and an instance {@link Topology2D}, which specifies
	 * the the geometry of neighborhoods about member Cells
	 * @param intArray the generating array.
	 * @param topo the Topology of this
	 * @see {@link Topology2D}, {@link Automaton2D}, {@link Cell}
	 */
	public CellArray2D(int[][] intArray, Topology2D topo) {
		this(initializeCells(intArray), topo);
	}

	/**
	 * Creates a {@link CellArray2D} from an array of Cells and an instance {@link Topology2D}, which specifies
	 * the the geometry of neighborhoods about member Cells
	 * @param cells the generating array.
	 * @param topo the Topology of this
	 * @see {@link Topology2D}, {@link Automaton2D}, {@link Cell}
	 */
	protected CellArray2D(Cell[][] cells, Topology2D topo) {
		this.length = cells.length;
		this.width = cells[0].length;
		this.cells = cells;
		this.topo = topo;
		
		String neighborhood = this.topo.getBasis().getMethodName();
		
		Class<?>[] args = {int.class, int.class, int.class};
		
		try {
			this.getNeighborhood = this.getClass().getMethod(neighborhood, args);
		} catch (NoSuchMethodException | SecurityException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Initializes a {@link Cell}[][] from an integer array. A living Cell is placed in the index corresponding 
	 * to a value of 1 in the input integer array and dead cells are placed everywhere else. 
	 * @param intArray the input array.
	 * @return the array of Cells generated by input array.
	 */
	protected static Cell[][] initializeCells(int[][] intArray) {
		Cell[][] cells = new Cell[intArray.length][intArray[0].length];
		for (int i = 0; i < intArray.length; i++) {
			for (int j = 0; j < intArray[0].length; j++)
				cells[i][j] = new Cell(intArray[i][j]);
		}
		return cells;
	}

	protected static boolean boundariesOK(int ii, int i, int min, int max) {
		return (!(ii < min) && !(ii >= max) && (ii != i));
	}

	/**
	 * Retrieves the number of living {@link Cell}s in the vertical neighborhood about the
	 * ij-th cell of radius r.
	 * @param i row index containing the central cell.
	 * @param j column index containing the central cell.
	 * @param r the radius of the neighborhood.
	 * @return the number of living cells.
	 */
	public int getVertical(int i, int j, int r) {

		int sum = 0;
		int imax = this.length;
		int jmax = this.width;
		for (int n = 0; n <= 2 * r; n++) {
			int ii = topo.idI(i - r + n, j, imax, jmax);
			int jj = topo.idJ(i, j, imax, jmax);
			
			if ( 
				(!(ii < 0) && !(ii >= imax)) &&
				(!(jj < 0) && !(jj >= jmax)) && 
				(ii != i || jj != j )
			   )
			{
				sum += this.getCell(ii, jj).toBit();
			}
		}
		
		return sum;
	}

	/**
	 * Retrieves the number of living {@link Cell}s in the horizontal neighborhood about the ij-th
	 * cell of radius r.
	 * @param i row index containing the central cell.
	 * @param j column index containing the central cell.
	 * @param r radius if the neighborhood.
	 * @return the number of living cells.
	 */
	public int getHorizontal(int i, int j, int r) {
		int sum = 0;
		int imax = this.length;
		int jmax = this.width;
		for (int n = 0; n <= 2 * r; n++) {
			int ii = topo.idI(i, j - r + n, imax, jmax);
			int jj = topo.idJ(i, j - r + n, imax, jmax);
			if ( (!(ii < 0) && !(ii >= imax)) && (!(jj < 0) && !(jj >= jmax)) && (ii != i || jj != j ) ) {
				sum += this.getCell(ii,jj).toBit();
			}
		}
		return sum;
	}

	/**
	 * Retrieves the {@link Cell}s in the right-hand diagonal neighborhood
	 * about the ij-th cell of radius r.
	 * @param i row index containing the central cell.
	 * @param j column index containing the central cell.
	 * @param r radius if the neighborhood.
	 * @return the number of living cells.
	 */
	public int getRightDiag(int i, int j, int r) {
		int sum = 0;
		int imax = this.length;
		int jmax = this.width;
		for (int n = 0; n <= 2 * r; n++) {
			int ii = topo.idI(i + r - n, j - r + n, imax, jmax);
			int jj = topo.idJ(i, j - r + n, imax, jmax);
			if ( (!(ii < 0) && !(ii >= imax)) && (!(jj < 0) && !(jj >= jmax)) && (ii != i || jj != j ) ) {
				sum += this.getCell(ii, jj).toBit();
			}
		}
		return sum;
	}

	/**
	 * Retrieves the number of living {@link Cell}s in the left-hand diagonal neighborhood
	 * about the ij-th cell of radius r.
	 * @param i row index containing the central cell.
	 * @param j column index containing the central cell.
	 * @param r radius if the neighborhood.
	 * @return the number of living cells.
	 */
	public int getLeftDiag(int i, int j, int r) {
		int sum = 0;
		int imax = this.length;
		int jmax = this.width;
		for (int n = 0; n <= 2 * r; n++) {
			int ii = topo.idI(i - r + n, j - r + n, imax, jmax);
			int jj = topo.idJ(i, j - r + n, imax, jmax);
			if (boundariesOK(ii, i, 0, imax) && boundariesOK(jj, j, 0, jmax)) {
				sum += this.getCell(ii,jj).toBit();
			}
		}
		return sum;
	}
	
	/**
	 * Returns the number of living {@link Cell}s in the Moore neighborhood about the ij-th cell. 
	 * @param i row index containing the central cell.
	 * @param j column index containing the central cell.
	 * @return the number of living cells.
	 */
	public int moore(int i, int j, int r ) {
		int sum = 0;
		int imax = this.length;
		int jmax = this.width;
		for (int n = 0; n <= 2*r; n++){
			for (int m = 0; m <= 2*r; m++){
				int ii = topo.idI(i - r + n, j - r + m, imax, jmax);
				int jj = topo.idJ(i, j - r + m, imax, jmax);
				if ( (!(ii < 0) && !(ii >= imax)) && (!(jj < 0) && !(jj >= jmax)) && (ii != i || jj != j )) {
					sum += this.getCell(ii,jj).toBit();
				}
			}

		}
		return sum;
	}
	
	/**
	 * Returns the number of living {@link Cell}s in the Von Neumann neighborhood of radius r about the ij-th cell.
	 * @param i row index containing the central cell.
	 * @param j column index containing the central cell.
	 * @param r radius of the neighborhood.
	 * @return the number of living cells.
	 */
	public int vonNeumann(int i, int j, int r) {
		int sum = 0;
		sum += this.getVertical(i, j, r);
		sum += this.getHorizontal(i, j, r);
		sum += this.getRightDiag(i, j, r-1);
		sum += this.getLeftDiag(i, j, r-1);
		return sum;
	}
	
	/**
	 * Returns the number of living {@link Cell}s in the neighborhood consisting of the north-west and south-east corners of
	 * radius r about the ij-th cell.
	 * @param i row index containing the central cell.
	 * @param j column index containing the the cental cell.
	 * @param r radius of the neighborhood
	 * @return the number of living cells.
	 */
	public int leftCorners(int i, int j, int r){
		int sum = 0;
		sum += this.getLeftDiag(i, j, r);
		sum += this.getVertical(i, j, r);
		sum += this.getHorizontal(i, j, r);
		return sum;
	}
	
	/**
	 * Returns the number of living {@link Cell}s in the neighborhood consisting of the north-east and south-west corners of
	 * radius r about the ij-th cell.
	 * @param i row index containing the central cell.
	 * @param j column index containing the the cental cell.
	 * @param r radius of the neighborhood
	 * @return the number of living cells.
	 */
	public int rightCorners(int i, int j, int r){
		int sum = 0;
		sum += this.getRightDiag(i, j, r);
		sum += this.getVertical(i, j, r);
		sum += this.getHorizontal(i, j, r);
		return sum;
	}
	/**
	 * Gets the neighborhood that is specified by this topology
	 * @param i first index of the neighborhood center
	 * @param j second index of the neighborhood center
	 * @return 
	 */
	
	public int getNeighborhood(int i, int j){
		
		int r = this.topo.coarseness;
		
		try {
			return (int) getNeighborhood.invoke(this, i, j, r);
			
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			e.printStackTrace();
			return 0;
		}
	}
	
	/**
	 * Gives an array of binary Values corresponding to the {@link Cell}s in this.
	 * 1 indicates that the Cell is alive and 0 indicates that it is dead.
	 * @return the binary array represented the states of Cells in this
	 */
	public int[][] toArray() {
		int[][] bin = new int[this.length][this.width];
		for (int i = 0; i < this.length; i++) {
			for (int j = 0; j < this.width; j++) {
				bin[i][j] = this.getCell(i, j).toBit();
			}
		}
		return bin;
	}


	/**
	 * Counts the number of living {@link Cell}s in this
	 * @return the number of Cells in this.
	 */
	public int livingCells() {
		int sum = 0;
		for (int i = 0; i < this.length; i++) {
			for (int j = 0; j < this.width; j++) {
				sum += this.cells[i][j].toBit();
			}
		}
		return sum;
	}

	/**
	 * Retrieves the {@link Cell} in the ij-th position of this.
	 * @param i row position
	 * @param j column position
	 * @return the Cell 
	 */
	public Cell getCell(int i, int j) {
		return this.cells[i][j];
	}

	/**
	 * Kills the {@link Cell} at the ij-th position of this
	 * @param i row position 
	 * @param j column position
	 */
	public void killCell(int i, int j) {
		this.cells[i][j].kill();
	}

	/**
	 * Resurrects the {@link Cell} at the ij-th position in this
	 * @param i row position
	 * @param j column position
	 */
	public void reviveCell(int i, int j) {
		this.cells[i][j].revive();
	}
	
	public void setTopology(Topology2D topo){
		this.topo = topo;
		String neighborhood = this.topo.getBasis().getMethodName();
		Class<?>[] args = {int.class, int.class, int.class};
		try {
			this.getNeighborhood = this.getClass().getMethod(neighborhood, args);
		} catch (NoSuchMethodException | SecurityException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Translates this into a String containing binary integers representing the {@link Cell} states of this.
	 * @return a string representing this.
	 */
	@Override
	public String toString() {
		StringBuilder theString = new StringBuilder();
		theString.append("[");
		for (int i = 0; i < this.length; i++) {
			theString.append("[");
			for (int j = 0; j < this.width; j++) {
				theString.append(this.cells[i][j].toBit());
				if (j < this.width - 1)
					theString.append(", ");
			}
			theString.append("]");
			if (i < this.length)
				theString.append(", ");
		}
		theString.append("]");
		return theString.toString();
	}
}
